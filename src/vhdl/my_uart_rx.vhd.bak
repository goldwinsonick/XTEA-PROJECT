-- library
library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

-- entity
entity my_uart_rx is
port(
	clk: in std_logic;
	rst_n: in std_logic;
	rs232_rx: in std_logic;
	clk_bps: in std_logic;
	bps_start: out std_logic;
	rx_data: out std_logic_vector(7 downto 0);
	rx_int : out std_logic
);
end entity my_uart_rx;

--
--module my_uart_rx(
--				clk,rst_n,
--				rs232_rx,rx_data,rx_int,
--				clk_bps,bps_start
--			);
--
--input clk;		// 50MHz
--input rst_n;	//
--input rs232_rx;	// RS232
--input clk_bps;	// clk_bps
--output bps_start;		//
--output[7:0] rx_data;
--output rx_int;	//

architecture RTL of my_uart_rx is
-- signal for interrupt
signal rs232_rx0,rs232_rx1,rs232_rx2,rs232_rx3: std_logic;
signal neg_rs232_rx: std_logic;
--reg rs232_rx0,rs232_rx1,rs232_rx2,rs232_rx3;	
--wire neg_rs232_rx;	//

	signal bps_start_r: std_logic;
	signal num: unsigned(3 downto 0);
	signal rx_int_i: std_logic;
	
--reg bps_start_r;
--reg[3:0] num;	
--reg rx_int;		
--
	signal rx_temp_data, rx_data_r: std_logic_vector(7 downto 0);
--
--reg[7:0] rx_temp_data;	


begin

----------------------------------------------------------------

process(clk, rst_n)
begin
	if (rst_n = '0') then 
--		begin
			rs232_rx0 <= '0';
			rs232_rx1 <= '0';
			rs232_rx2 <= '0';
			rs232_rx3 <= '0';
		
--		end;
	elsif (clk='1' and clk'event) then
--		begin
			rs232_rx0 <= rs232_rx;
			rs232_rx1 <= rs232_rx0;
			rs232_rx2 <= rs232_rx1;
			rs232_rx3 <= rs232_rx2;
--		end;
	end if;
end process;

--always @ (posedge clk or negedge rst_n) begin
--	if(!rst_n) begin
--			rs232_rx0 <= 1'b0;
--			rs232_rx1 <= 1'b0;
--			rs232_rx2 <= 1'b0;
--			rs232_rx3 <= 1'b0;
--		end
--	else begin
--			rs232_rx0 <= rs232_rx;
--			rs232_rx1 <= rs232_rx0;
--			rs232_rx2 <= rs232_rx1;
--			rs232_rx3 <= rs232_rx2;
--		end
-- end

--assign neg_rs232_rx = rs232_rx3 & rs232_rx2 & ~rs232_rx1 & ~rs232_rx0;	
	neg_rs232_rx <= rs232_rx3 and rs232_rx2 and (not rs232_rx1) and (not rs232_rx0);

	-- //----------------------------------------------------------------

	process( clk, rst_n)
	begin
		if (rst_n = '0') then
				bps_start_r <= 'Z';
				rx_int_i <= '0';
		elsif clk = '1' and clk'event then
			if (neg_rs232_rx= '1') then
				bps_start_r <= '1';	
				rx_int_i <= '1';			
			elsif (num = "1011") then
				bps_start_r <= '0';
				rx_int_i <= '0';		
			end if;
		end if;
	end process;

--always @ (posedge clk or negedge rst_n)
--	if(!rst_n) begin
--			bps_start_r <= 1'bz;
--			rx_int <= 1'b0;
--		end
--	else if(neg_rs232_rx) begin		
--			bps_start_r <= 1'b1;	
--			rx_int <= 1'b1;			
--		end
--	else if(num==4'd11) begin		
--			bps_start_r <= 1'b0;
--			rx_int <= 1'b0;			
--		end

	bps_start <= bps_start_r;

----------------------------------------------------------------
-- reg[7:0] rx_data_r;	
----------------------------------------------------------------
	process(clk, rst_n)
	begin
		if (rst_n = '0') then
				rx_temp_data <= "00000000";
				num <= "0000";
				rx_data_r <= "00000000";		
		elsif (clk = '1' and clk'event) then
			if (rx_int_i = '1') then
				if(clk_bps = '1') then
						num <= num + "0001";
						case num is
								when "0001" =>  rx_temp_data(0) <= rs232_rx;	--//0bit
								when "0010" =>  rx_temp_data(1) <= rs232_rx;	--//1bit
								when "0011" =>  rx_temp_data(2) <= rs232_rx;	--//2bit
								when "0100" =>  rx_temp_data(3) <= rs232_rx;	--//3bit
								when "0101" =>  rx_temp_data(4) <= rs232_rx;	--//4bit
								when "0110" =>  rx_temp_data(5) <= rs232_rx;	--//5bit
								when "0111" =>  rx_temp_data(6) <= rs232_rx;	--//6bit
								when "1000" =>  rx_temp_data(7) <= rs232_rx;	--//7bit
								when others =>  
						end case;
--					end;
				elsif (num = "1101") then
						num <= "0000";			
						rx_data_r <= rx_temp_data;	
				end if;
			end if;
		end if;
	end process;


--always @ (posedge clk or negedge rst_n)
--	if(!rst_n) begin
--			rx_temp_data <= 8'd0;
--			num <= 4'd0;
--			rx_data_r <= 8'd0;
--		end
--	else if(rx_int) begin
--		if(clk_bps) begin		
--				num <= num+1'b1;
--				case (num)
--						4'd1: rx_temp_data[0] <= rs232_rx;	//0bit
--						4'd2: rx_temp_data[1] <= rs232_rx;	//1bit
--						4'd3: rx_temp_data[2] <= rs232_rx;	//2bit
--						4'd4: rx_temp_data[3] <= rs232_rx;	//3bit
--						4'd5: rx_temp_data[4] <= rs232_rx;	//4bit
--						4'd6: rx_temp_data[5] <= rs232_rx;	//5bit
--						4'd7: rx_temp_data[6] <= rs232_rx;	//6bit
--						4'd8: rx_temp_data[7] <= rs232_rx;	//7bit
--						default: ;
--					endcase
--			end
--		else if(num == 4'd11) begin		
--				num <= 4'd0;			
--				rx_data_r <= rx_temp_data;	
--			end
--		end

	rx_data <= rx_data_r;	
	rx_int <= rx_int_i;
	
end architecture;
